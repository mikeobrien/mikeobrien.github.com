---
layout: post
title: Solving Project Euler Problem #2 in F#
categories: [Math, F#, Algebra, Project Euler]
tags: [Math, F#, Algebra, Project Euler]
---
<p><a href="http://projecteuler.net/">Project Euler</a> rocks! I think it's an especially good way to learn another programming language. I'm planning to try to solve the problems in 2 ways. First, if possible, the brute force method (Which I think helps you to learn the language better) and second, if possible, the formula method (Which I think helps you learn the mathematical concepts better). </p>  <p><a href="http://projecteuler.net/index.php?section=problems&id=2">Problem #2</a> states:</p> <font color="#008000" size="2"><font color="#008000" size="2">     <p>Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:</p>      <p>1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...</p>      <p>Find the sum of all the even-valued terms in the sequence which do not exceed four million.</p>   </font></font>  <p><strong>Solution 1</strong></p>  <p>So the first approach is using the brute force method where we iterate through all the numbers and determine the next Fibonacci number by adding the last two. I used the Seq.unfold method to do this (Which I discuss further <a href="/2009/08/folding-and-unfolding-in-f-and-linq.html">here</a>). Short and sweet:</p>  <pre class="code"><span style="color: blue">let </span>max = 4000000
    
<span style="color: blue">let </span>fib = Seq.unfold (<span style="color: blue">fun </span>(last, current) <span style="color: blue">-> </span>Some (last, (current, current + last))) (1, 1)
     
<span style="color: blue">let </span>Run1 _ = 
    fib 
    |> Seq.takeWhile (<span style="color: blue">fun </span>i <span style="color: blue">-> </span>i <= max)
    |> Seq.filter (<span style="color: blue">fun </span>i <span style="color: blue">-> </span>i % 2 = 0)
    |> Seq.fold(<span style="color: blue">fun </span>state item <span style="color: blue">-> </span>state + item) 0
    |> Display.PrintInteger</pre>
<a href="http://11011.net/software/vspaste"></a>

<p><strong>Solution 2</strong></p>

<p>The second approach actually calculates each Fibonacci number using the <a href="http://mathworld.wolfram.com/BinetsFibonacciNumberFormula.html">Binet formula</a>. Now this is still pretty much brute force in that we still have to iterate from 0 to the max and include only the positive values, but at least we're using a formula that doesn't require knowledge of the previous values in the sequence. <a href="http://www.computing.surrey.ac.uk/personal/ext/R.Knott/contactron.html">Ron Knott</a> has a <a href="http://www.computing.surrey.ac.uk/personal/ext/R.Knott/Fibonacci/fibFormula.html">nice page on calculating Fibonacci numbers</a> and a "reduced" Binet for calculating positive integers.&#160; The reduced Binet formula is <font color="#0000a0" size="2" face="Courier New">round(&#966;<sup>n</sup> / &#8730;5)</font>. The rounding is required because of the irrational numbers in the equation. Theoretically the result would be an integer but because of limits on the number of digits we can calculate, the result will be slightly off and the rounding fixes this. I discuss calculating &#966; (Or the Golden Ratio) in my <a href="/2009/10/determining-golden-ratio.html">last post</a>. Check that out to get a better understanding of how we calculate it. </p>

<pre class="code"><span style="color: blue">let </span>max = 4000000

<span style="color: blue">let </span>sqrt5 = sqrt 5.0
<span style="color: blue">let </span>Phi = (1.0 + sqrt5) / 2.0
<span style="color: blue">let </span>fibn n = Phi ** float n / sqrt5 |> round |> int
<span style="color: blue">let </span>fib2 = Seq.unfold (<span style="color: blue">fun </span>index <span style="color: blue">-> </span>Some (fibn index,index + 1)) 1

<span style="color: blue">let </span>Run2 _ = 
    fib2 
    |> Seq.takeWhile (<span style="color: blue">fun </span>i <span style="color: blue">-> </span>i <= max)
    |> Seq.filter (<span style="color: blue">fun </span>i <span style="color: blue">-> </span>i % 2 = 0)
    |> Seq.fold(<span style="color: blue">fun </span>state item <span style="color: blue">-> </span>state + item) 0
    |> Display.PrintInteger</pre>
<a href="http://11011.net/software/vspaste"></a>

<p><strong>Results</strong></p>

<p><font color="#ff0000">EDIT:</font> After the fact I realized that my original results were skewed by the JIT compiler. Anyways, made some modifications to take this out of the equation and got more accurate results. As you can see in this case that the heavier calculations in solution 2 don't buy us any performance since we have to iterate through and find the positive numbers starting from 0 anyways. So solution 1 was the best solution in this case. However if we needed to target a specific range of Fibonacci numbers (Especially a high range) the second solution would most definitely win out.&#160; </p>

<p><a href="http://blog.mikeobrien.net/content/binary/WindowsLiveWriter/SolvingProjectEulerProblem2inF_12E23/image_4.png"><img style="border-right-width: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px" title="image" border="0" alt="image" src="/content/28dabe0770974d2eac8ddca7fa8bbcac.png" width="677" height="342" /></a></p>