---
layout: post
title: On Filters in MVC3
tags: [ASP.NET MVC3, .NET 4.0]
---
<p>I've been digging into the new filter functionality in MVC3 and this is a brain dump of what I've learned and some thoughts.</p>  <p>Filters currently must implement one or more of these interfaces: <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.iactionfilter.aspx">IActionFilter</a>, <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.iresultfilter.aspx">IResultFilter, </a><a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.iexceptionfilter.aspx">IExceptionFilter</a>, and <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.iauthorizationfilter.aspx">IAuthorizationFilter</font></a>. The <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.imvcfilter.aspx">IMvcFilter</a> interface allows you to tack on some additional metadata like the sort order and multiplicity. There are a couple of convenience classes that make creating filter <strong><em>attributes</em></strong> easier: <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.filterattribute.aspx">FilterAttribute</a>, <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.actionfilterattribute.aspx">ActionFilterAttribute</a>, <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.authorizeattribute.aspx">AuthorizeAttribute</a>, <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.handleerrorattribute.aspx">HandleErrorAttribute</a> and a few more. FilterAttribute implements <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.imvcfilter.allowmultiple.aspx">IMvcFilter</a> and so provides that metadata out of the box. When deriving from any of these attribute classes its important to understand that disallowing multiple instances of a filter is accomplished by applying the <span style="widows: 2; text-transform: none; text-indent: 0px; letter-spacing: normal; border-collapse: separate; font: medium &#39;Times New Roman&#39;; white-space: normal; orphans: 2; color: rgb(0,0,0); word-spacing: 0px; -webkit-border-horizontal-spacing: 0px; -webkit-border-vertical-spacing: 0px; -webkit-text-decorations-in-effect: none; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px" class="Apple-style-span"><span style="text-align: left; line-height: 18px; font-family: &#39;Trebuchet MS&#39;, arial; font-size: small; -webkit-border-horizontal-spacing: 2px; -webkit-border-vertical-spacing: 2px" class="Apple-style-span"><a style="background-color: transparent; color: rgb(0,50,77); font-weight: bold; text-decoration: underline; background-origin: initial; background-clip: initial" href="http://msdn.microsoft.com/en-us/library/system.attributeusageattribute.aspx">AttributeUsageAttribute</a> to your derived class and setting <a href="http://msdn.microsoft.com/en-us/library/system.attributeusageattribute.allowmultiple.aspx">AllowMultiple</a> to false. The <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.filterattribute.aspx">FilterAttribute</a> class looks for that attribute to determine multiplicity and exposes it through the <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.imvcfilter.allowmultiple.aspx">IMvcFilter.AllowMultiple property</a>.</span></span></p>  <p>Originally filters (Which is a terrible name BTW. What do they filter??) were applied as .NET attributes to actions or controllers. At the beginning of the request, the controller and action filter attributes were pulled from the action method and controller class and run. One thing to note is that .NET attributes are only created by the CLR once (they are essentially singletons) so every time you reflect them in a particular app domain you will get the same object instances. I think the whole attribute approach for filters is badly implemented. One of the problems is that if you want to inject dependencies into an filter you have to rig up property injection. Additionally since they are attributes, and essentially singletons, they cannot hold any request specific state. This may be fine for something like authentication but difficult for transaction management as you will not be able to use IoC to inject request specific dependencies. I think a better design would have been to make the attributes more like WCF behaviors where the attribute itself is not the filter but simply acts as a way to create the filter. But that's neither here nor there.</p>  <p>Now moving on to MVC3; things have changed a bit. We now have this concept of the <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.ifilterprovider.aspx">IFilterProvider</a> interface. This interface has one method, GetFilters() which as you can probably guess returns filters. Filter providers are now the source of all filters. There are three filter providers <a href="http://bradwilson.typepad.com/blog/2010/07/service-location-pt4-filters.html">registered out of the box</a>: </p>  <ol>   <li><strong><a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.globalfilters.filters.aspx">GlobalFilters.Filters</a>:</strong> This is simply a place where you can ad-hoc register individual filters that will be applied globally. These should be stateless as they will be reused for each request. </li>    <li><strong><a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.filterattributefilterprovider.aspx">FilterAttributeFilterProvider</a>:</strong> This provider uses reflection to pull filters applied as attributes to controller classes and action methods; it basically does the job that the pre MVC3 code did. So the filters that this provider returns are not global, they are scoped to the controller and action. Since they are attributes they are essentially singletons and will be reused for each request so they should be stateless. Also keep in mind that the <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.filterattributefilterprovider.aspx">FilterAttributeFilterProvider</a> will only discover attributes that derive from <a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.filterattribute.aspx">FilterAttribute</a>. So deriving from <a href="http://msdn.microsoft.com/en-us/library/system.attribute.aspx">Attribute</a> and then implementing a filter interface will not get your attribute picked up by this provider. </li>    <li><strong><a href="http://msdn.microsoft.com/en-us/library/system.web.mvc.controllerinstancefilterprovider(v=vs.98).aspx">ControllerInstanceFilterProvider</a>:</strong> This provider allows the controller servicing the request to act as a filter (ee gads!). </li> </ol>  <p>MVC calls the FilterProviders.Providers.GetFilters() method, to aggregate all the filters from all the filter providers, for each individual request. You can also register your own filter providers by adding an instance of a type that implements IFilterProvider to the FilterProviders.Providers collection. FilterProviders wrap filters in the Filter class which adds some additional information such as the scope and order. You can override the order in the Filter class constructor if you are writing your own filter provider or extending an existing one. If you don't pass in an order it will check and see if the filter implements IMvcFilter and get the order from there otherwise it defaults to -1. One interesting thing about the code that aggregates all these is that it removes duplicate filters for those filters that do not allow duplicates (Exposed by the IMvcFilter.AllowMultiple property). The way it determines which ones to remove is by sorting the filters by the order and then by the scope and preserving the first instance it encounters and rejecting the subsequent instances. This means that higher orders win and then within an order, narrower scopes will win (Which is actually a higher scope number).</p>  <p><a href="http://blog.mikeobrien.net/2011/04/building-better-mvc-dependency-resolver.html">This post</a> demonstrates how to pull global filters from your favorite IoC container. </p>  