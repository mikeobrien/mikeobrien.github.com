---
layout: post
title: Dissecting the output of the CoffeeScript class and extends keyword
tags: [JavaScript, CoffeeScript, Underscore.js]
redirect_from:
  - /blog/2011/12/dissecting-output-of-coffeescript-class.html
---
<p>CoffeeScript has a convenient way of emulating class and inheritance semantics via the <a href="http://jashkenas.github.com/coffee-script/#classes">class and extends keyword</a>. I wanted to better understand what was happening under the covers so the following is an analysis of the transpiler output. We'll look at a simple relationship between two CS "classes":</p>  <pre class="code csharpcode"><span class="kwrd">class</span> Parent
    constructor: -&gt;
        <span class="preproc">@id</span> = ++Parent.identity
    @identity: 0

<span class="kwrd">class</span> Child extends Parent
    url: <span class="str">'http://www.google.com'</span></pre>
<style type="text/css">

.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }</style>

<p>CS outputs the following (As of <a href="http://github.com/jashkenas/coffee-script/tarball/1.2.0">1.2</a>):</p>

<pre class="code csharpcode"><span class="kwrd">var</span> Child, Parent;
<span class="kwrd">var</span> __hasProp = Object.prototype.hasOwnProperty, 
    __extends = <span class="kwrd">function</span>(child, parent) {<span class="rem">/* discussed later */</span>};

Parent = (<span class="kwrd">function</span>() {
    <span class="kwrd">function</span> Parent() {
        <span class="kwrd">this</span>.id = ++Parent.identity;
    }
    Parent.identity = 0;
    <span class="kwrd">return</span> Parent;
})();

Child = (<span class="kwrd">function</span>() {
    __extends(Child, Parent);
    <span class="kwrd">function</span> Child() {
        Child.__super__.constructor.apply(<span class="kwrd">this</span>, arguments);
    }
    Child.prototype.url = <span class="str">'http://www.google.com'</span>;
    <span class="kwrd">return</span> Child;
)();</pre>
<style type="text/css">

.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }</style>

<p>Some things I noted:</p>

<ul>
  <li>The CS transpiler builds the constructor functions in <a href="http://benalman.com/news/2010/11/immediately-invoked-function-expression/">IIFE's</a> so we don't clutter up the global object. </li>

  <li>The CS "constructor" property is the body of the constructor function. </li>

  <li>The CS @ prefix... 
    <ul>
      <li>... refers to the new object <em><strong>only</strong></em> when used in the constructor. </li>

      <li>... refers to the function object outside of the constructor (to declare "static" properties). </li>
    </ul>
  </li>

  <li>Properties not prefixed with the CS @ are prototype properties. </li>

  <li>The "parent" constructor function can be executed <em><strong>in the context of the new child object</strong></em>. This happens automatically (As shown above) if the child does not explicitly declare a constructor. If the child object does supply a constructor (And you want to call the parent constructor) you will need to manually call super(...) in the child constructor with zero or more arguments. </li>
</ul>

<p>Now lets take a look at the __extends method that is generated by CS. This method sets up the prototype chain and a property that links to the "parent" prototype. </p>

<pre class="code csharpcode">var __hasProp = Object.prototype.hasOwnProperty;
var __extends = function(child, parent) { 
    <span class="kwrd">for</span> (var key <span class="kwrd">in</span> parent) {
         <span class="kwrd">if</span> (__hasProp.call(parent, key)) 
            child[key] = parent[key]; 
    } 
    function ctor() { 
        <span class="kwrd">this</span>.constructor = child; 
    } 
    ctor.prototype = parent.prototype; 
    child.prototype = <span class="kwrd">new</span> ctor; 
    child.__super__ = parent.prototype; 
    <span class="kwrd">return</span> child; 
};</pre>
<style type="text/css">

.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }</style>

<p>Some things I noted:</p>

<ul>
  <li>All constructor function properties (Or "static" properties) are copied from the "parent" to the "child" constructor function.</li>

  <li>An intermediate prototype object is created so that you can augment the "child's" prototype without changing the "parent's" prototype. </li>

  <ul>
    <li>It's prototype is the "parent" prototype.</li>

    <li>It serves as the prototype of "child" objects. </li>

    <li>It's constructor is set to the "child" constructor function.</li>
  </ul>

  <li>A special property called __super__ is created on the "child" constructor function. Evidentially <a href="http://groups.google.com/group/nodejs/browse_thread/thread/b0fc3b31a90dc906">CS likes to be backwards compatible</a> as it doesn't make use of the <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Object/GetPrototypeOf">relatively new Object.getPrototypeOf method</a>. Calling super() in the CS constructor, as noted above, will make use of this property to call the "parent" constructor function.</li>
</ul>

<p>From this we can see that CS sets up the prototype chain like so:</p>

<p>&#160;</p>

<p><img style="background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: block; float: none; margin-left: auto; border-top: 0px; margin-right: auto; border-right: 0px; padding-top: 0px" title="CoffeeScriptPrototypeChain" border="0" alt="CoffeeScriptPrototypeChain" src="/blog/images/22298163a9a447798606c139d9694757.png" width="451" height="322" /></p>

<p>&#160;</p>

<p>One more thing I was interested in was how the CS extends keyword compares to the <a href="http://documentcloud.github.com/underscore/docs/underscore.html#section-68">underscore.js method of a similar name</a>:</p>

<pre class="code csharpcode">_.extend = <span class="kwrd">function</span>(obj) {
    each(slice.call(arguments, 1), <span class="kwrd">function</span>(source) {
        <span class="kwrd">for</span> (<span class="kwrd">var</span> prop <span class="kwrd">in</span> source) {
            <span class="kwrd">if</span> (source[prop] !== <span class="kwrd">void</span> 0) obj[prop] = source[prop];
        }
    });
    <span class="kwrd">return</span> obj;
};</pre>
<style type="text/css">
.csharpcode, .csharpcode pre
{
	font-size: small;
	color: black;
	font-family: consolas, "Courier New", courier, monospace;
	/*white-space: pre;*/
}
.csharpcode pre { margin: 0em; }
.csharpcode .rem { color: #008000; }
.csharpcode .kwrd { color: #0000ff; }
.csharpcode .str { color: #006080; }
.csharpcode .op { color: #0000c0; }
.csharpcode .preproc { color: #cc6633; }
.csharpcode .asp { background-color: #ffff00; }
.csharpcode .html { color: #800000; }
.csharpcode .attr { color: #ff0000; }
.csharpcode .alt 
{
	background-color: #f4f4f4;
	width: 100%;
	margin: 0em;
}
.csharpcode .lnum { color: #606060; }</style>Clearly they are very different. The underscore extend method basically does a mixin as it simply copies properties from the source objects to the target object.   